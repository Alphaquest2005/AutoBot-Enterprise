Concise Report: Typed Logging & Dynamic Filtering System
1. System Overview:
A typed logging system using Serilog has been implemented. Its purpose is to provide structured, categorized logs that can be dynamically filtered at runtime. This allows for minimal "proof of execution" logging by default, with the ability to enable highly detailed verbose logging for specific C# classes or methods during troubleshooting, without code changes or restarts.
2. Core Components (Located in Core.Common.Extensions namespace):
LogCategory (Enum - in LoggingCategories.cs):
Defines semantic log types: Undefined, MethodBoundary, ActionBoundary, InternalStep, ExternalCall, DiagnosticDetail, Performance, StateChange, Security, MetaLog.
Every log event generated by the typed extensions is tagged with one of these.
TypedLoggerExtensions (Static Class - in TypedLoggerExtensions.cs):
Provides extension methods for Serilog.ILogger instances (e.g., a field _log).
Examples: _log.LogMethodEntry(invocationId), _log.LogActionStart(invocationId, actionName), _log.LogInternalStep(invocationId, messageTemplate, params), _log.LogErrorCategorized(category, ex, template, invId, params).
Functionality:
Automatically enrich log events with:
LogCategory property (based on the extension method called).
MemberName, SourceFilePath, SourceLineNumber properties (via [Caller...] attributes).
InvocationId (pushed to Serilog.LogContext and often included as a property).
Wrap underlying Serilog calls (.Information(), .Debug(), etc.).
LogFilterState (Static Class - in LogFilterState.cs):
Controls the filter's runtime behavior. Properties are public static and can be modified.
EnabledCategoryLevels (Dictionary<LogCategory, Serilog.Events.LogEventLevel>):
Default View: Maps each LogCategory to a default minimum LogEventLevel (e.g., MethodBoundary -> Information, InternalStep -> Warning). Logs below this level for a given category are filtered out if no specific target is set.
TargetSourceContextForDetails (string): Set to the full class name (e.g., "MyNamespace.MyClass") to enable detailed logging for that class. null or empty means no class is specifically targeted.
TargetMethodNameForDetails (string): Optionally, set to a method name within TargetSourceContextForDetails for even more granular targeting. null or empty means all methods in the target class are detailed.
DetailTargetMinimumLevel (Serilog.Events.LogEventLevel): When a target is active, logs from that target are output if their level is >= DetailTargetMinimumLevel (e.g., Verbose to see everything from the target).
3. Serilog Configuration (Example from Test Setup - Apply to Application):
The Serilog.LoggerConfiguration must include:
1. .MinimumLevel.Verbose() (or the lowest level of any log you might want to capture).
2. .Enrich.FromLogContext()
3. .Enrich.WithProperty("MemberName", null) (if not already handled by an enricher, ensures property exists for filter access, though extensions add it).
4. .Filter.ByIncludingOnly(evt => { /* Filter Logic Below */ })
5. Appropriate sinks (.WriteTo.Console(), .WriteTo.File(), etc.).
4. Filter Logic Predicate (Core of Dynamic Behavior):
// Inside .Filter.ByIncludingOnly(evt => { ... })
// 1. Extract LogEvent properties:
//    - evt.Level (LogEventLevel)
//    - category (LogCategory, from evt.Properties["LogCategory"])
//    - sourceContext (string, from evt.Properties["SourceContext"])
//    - memberName (string, from evt.Properties["MemberName"])

// 2. Targeted Troubleshooting Logic:
// IF LogFilterState.TargetSourceContextForDetails is set AND matches evt.SourceContext:
//   IF LogFilterState.TargetMethodNameForDetails is set AND matches evt.MemberName (OR TargetMethodNameForDetails is null/empty):
//     RETURN (evt.Level >= LogFilterState.DetailTargetMinimumLevel);
//   ENDIF
// ENDIF

// 3. General Category-Based Filtering Logic (if not returned by targeted logic):
// IF LogFilterState.EnabledCategoryLevels.TryGetValue(category, out var configuredMinLevelForCategory):
//   RETURN (evt.Level >= configuredMinLevelForCategory);
// ENDIF

// 4. Default:
// RETURN false; // Exclude if no rule explicitly includes it
Use code with caution.
C#
5. How to Use This System:
For Default Logging (Proof of Execution):
Ensure LogFilterState.TargetSourceContextForDetails = null;
LogFilterState.EnabledCategoryLevels will dictate output (e.g., MethodBoundary at Information will show; InternalStep at Debug will be hidden if its default enabled level is Warning).
For Detailed Troubleshooting of MyNamespace.MyClass.MyMethod:
Set LogFilterState.TargetSourceContextForDetails = "MyNamespace.MyClass";
Set LogFilterState.TargetMethodNameForDetails = "MyMethod";
Set LogFilterState.DetailTargetMinimumLevel = Serilog.Events.LogEventLevel.Verbose; (or Debug).
Execute the code path. Logs from MyNamespace.MyClass.MyMethod will appear down to Verbose. Other code will follow default EnabledCategoryLevels.
Important: Reset LogFilterState values to null/defaults after troubleshooting.
Adding New Logs:
Use the extension methods from TypedLoggerExtensions on an ILogger instance (e.g., _log.LogMethodEntry(invocationId);, _log.LogInternalStep(invocationId, "Detail: {Data}", data);).
invocationId should be passed to ensure it's available in the LogContext and as a property.
6. Key Files for an LLM to Review/Understand:
* Core.Common.Extensions/LoggingCategories.cs
* Core.Common.Extensions/TypedLoggerExtensions.cs
* Core.Common.Extensions/LogFilterState.cs
* The Serilog configuration code block (where .Filter.ByIncludingOnly(...) is defined).
* AutoBotUtilities.Tests/TypedLoggingFilterTests.cs (as a working example of configuration and usage).
7. Current Task (If continuing from previous session):
* Complete refactoring of static Log.Error() calls in AutoBotUtilities.Tests/EmailDownloaderIntegrationTests.cs to use _log.LogErrorCategorized(...), ensuring correct parameter passing (especially propertyValues: new object[]{...} if applicable).
* Integrate the full filter configuration into EmailDownloaderIntegrationTests.cs's [OneTimeSetUp].
* Build and then run ProcessEmailsAsync_ImportsPdfFromEmail_IntegrationTest, using LogFilterState to get detailed logs for diagnosing the original test failure.
This concise report should equip an LLM to understand the implemented logging system's structure, how to use it for diagnosis by manipulating LogFilterState, and how to contribute new logging adhering to the established patterns.